+ GIT!!!!

+ GIT!!!!

+ GIT!!!!

+ GIT!!!!

+ GIT!!!!

+ GIT!!!!

+ GIT!!!!

- usar 'printf -v'!!!

- para recargar reglas de udev (SIN inotify, con lo cual funciona con links simbolicos... asumo)
  http://reactivated.net/writing_udev_rules.html
    ver "Testing and debugging > Putting your rules into action"

- para verificar que los comandos que necesitamos esten usar cosas de:
  http://wiki.bash-hackers.org/scripting/style#behaviour_and_robustness

- hacer internacionalizacion de strings (http://mywiki.wooledge.org/BashFAQ/098) (para esto por ahi conviene empezar a usar printf en lugar de echo)

- hacer output coloreado
  echo "$(tput bold)"; echo "$(tput setaf 5)FATAL"; echo "$(tput setaf 1)ERROR"; echo "$(tput setaf 3)WARNING"; echo "$(tput setaf 2)INFO"; echo "$(tput setaf 6)DEBUG"; echo "$(tput setaf 4)STDERR"
  para ver si esta terminal soporta output coloreado: (http://unix.stackexchange.com/questions/9957/how-to-check-if-bash-can-print-colors)
  $(tput colors) da la cantidad de colores que se banca

- hacer un FIFO para el stderr de los subcomandos (este tiene un "listener" que le agrega un header a cada linea)

- hacer el tema de setear la trap para DEBUG y loguear todo comando que se ejecute (http://mywiki.wooledge.org/BashFAQ/050)

- hacer una nueva "action" que muestre el log coloreado, si se le pasa una lista de RUNHASHes los va mostrando de a uno, si no busca la maquina que este corriendo ahora y muestra esa, por vmuuid o por vmname tambien

+ hacer que la action START tome una lista de devpaths a attachear al inicio

+ hacer que la action ATTACH tome varios devpaths

+ en caso de start considerar el parseo de la opcion "--" (porque ahora toma una lista de opciones)

- en caso de logs considerar el parseo de la opcion "--" (porque ahora toma una lista de opciones)

- OPCIONAL: hacer un parser de opciones de linea de comando como la gente

+ hacer que machine-readable sea el default cuando se llama desde algo que no sea una tty
  
