DONE:

+ GIT!!!!

+ hacer output coloreado
  echo "$(tput bold)"; echo "$(tput setaf 5)FATAL"; echo "$(tput setaf 1)ERROR"; echo "$(tput setaf 3)WARNING"; echo "$(tput setaf 2)INFO"; echo "$(tput setaf 6)DEBUG"; echo "$(tput setaf 4)STDERR"
  para ver si esta terminal soporta output coloreado: (http://unix.stackexchange.com/questions/9957/how-to-check-if-bash-can-print-colors)
  $(tput colors) da la cantidad de colores que se banca

+ hacer un FIFO para el stderr de los subcomandos (este tiene un "listener" que le agrega un header a cada linea)

+ hacer el tema de setear la trap para DEBUG y loguear todo comando que se ejecute (http://mywiki.wooledge.org/BashFAQ/050)

+ hacer que la action START tome una lista de devpaths a attachear al inicio

+ hacer que la action ATTACH tome varios devpaths

+ en caso de start considerar el parseo de la opcion "--" (porque ahora toma una lista de opciones)

+ hacer que machine-readable sea el default cuando se llama desde algo que no sea una tty

+ cambiar log para que refleje el formato: log LOGFILE SEVERITY FORMAT [PARAMS...]
  donde FORMAT es un formato de printf y PARAMS los parametros a pasarle

+ hacer internacionalizacion de strings (http://mywiki.wooledge.org/BashFAQ/098) (para esto por ahi conviene empezar a usar printf en lugar de echo)

+ hacer que la trap de DEBUG no loguee la funcion "log"

+ definir variables de entorno de donde se saquen los defaults para muchas variables de opciones nuestras

+ reorganizar temas de paths (ie. que el logfile apunte al path completo, no solo al nombre hardcodeando "/tmp")

+ reorganizar el orden en el que se declaran / lanzan los comandos, sobre todo al principio de todo, cuando se lanzan los traps

+ para verificar que los comandos que necesitamos esten usar cosas de:
  http://wiki.bash-hackers.org/scripting/style#behaviour_and_robustness

+ en caso de logs considerar el parseo de la opcion "--" (porque ahora toma una lista de opciones)

+ ver si el artilugio de leer con "<>" se puede usar para simplificar el printListener()

+ ver como hacer para que el jobcontrol de BASH no rompa los huevos al final de una corrida avisando que se terminaron los listeners

+ !!! verificar que no quede corriendo inotifywait !!!



TODO:

- ver como hacer para que pueda evitar forwardear un evento ACPI a VB (VB los forwardea por defecto al parecer y no esta claro como evitar que haga esto, con lo cual los switches "-f" o "--no-acpi-forward" no andan)

- hacer una nueva "action" que muestre el log coloreado, si se le pasa una lista de RUNHASHes los va mostrando de a uno, si no busca la maquina que este corriendo ahora y muestra esa, por vmuuid o por vmname tambien, hacer que tome argumentos adicionales que digan que "niveles" mostrar (ie. --show-error, --no-show-error, --show-info, --no-show-info, etc), y OJO con que los logs pueden estar comprimidos.

- para recargar reglas de udev (SIN inotify, con lo cual funciona con links simbolicos... asumo)
  http://reactivated.net/writing_udev_rules.html
    ver "Testing and debugging > Putting your rules into action"

- OPCIONAL: hacer un parser de opciones de linea de comando como la gente

- OPCIONAL: hacer un printf como la gente (ie. que se banque "tags" como '%s:key' y que se le pase una array asociativa que reemplaza segun "key")

  s='hola :k1 lalala :k2lolo :k1 chau'
  declare -A arr; arr['k1']='K1'; arr['k2']='K2'
  t=$s; for k in ${!arr[@]}; do t=${t//:$k/${arr[$k]}}; done; t=${t//:_/:}; echo ">>>$t<<<"

  >>>hola K1 lalala K2lolo K1 chau<<<

  esto hace que las "tags" del estilo ":<nombre>" se reemplacen por el valor asociado a la clave "<nombre>" en el array dado; la ultima regla (que reemplaza ":_" por ":") esta para permitir que en el texto de salida aparezca algo de la forma ":<nombre>" sin que sea reemplazado.

- Bug: VBox has problems to attach modems (i.e. Bluetooth).

- Bug: VBox has problems to habilitate the sleep (and hibernate) option under Windows.
