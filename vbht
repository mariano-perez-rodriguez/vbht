#! /usr/bin/env bash

##
## vbht - VirtualBox(R) Host Tools -- kiosk-mode host tools for VirtualBox(R)
## Copyright (C) 2012  Mariano Perez Rodriguez
##
## This program is free software: you can redistribute it and/or modify it
## under the terms of the GNU Affero General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU Affero General Public License for more details.
##
## You should have received a copy of the GNU Affero General Public License
## along with this program. If not, see <http://www.gnu.org/licenses>.
##

set +H          # DISABLE HISTORY EXPANSION FOR CRYING OUT LOUD!!!
set -o nounset  # be merciless about unset variables
set -o errexit  # exit on ANY error
set -E          # propagate errexit
set -T          # propagate DEBUG and RETURN traps


# ==============================================================================
# == Localisation ==============================================================
# ==============================================================================

# NB: in order to obtain the pot file for vbht do:
#     bash --dump-po-strings vbht | msguniq --no-wrap --sort-by-file > vbht.pot

# set up domain directory
# @TODO: maybe put it in /opt/vbht???
# TEXTDOMAINDIR=/usr/local/share/locale
# set up domain
TEXTDOMAIN=vbht


# ==============================================================================
# == Basic utilities ===========================================================
# ==============================================================================

# Key-based printf-like function
#
# Usage print FORMAT [KEY:VALUE...]
# Returns: 0, always
# Outputs: string FORMAT, where every occurrence of `:KEY' has been replaced
#          by `VALUE' (incidentally, every occurrence of `:.' will be replaced
#          by `:' in order to provide for escaping)
# Depends: nothing
print() {
  # reps will hold the replacements to be done
  local -A reps
  # temporary
  local key
  # keys must conform to this regex
  local re='^[a-zA-Z0-9]+$'
  # initialise output with format and shift it out
  local out="${1}"; shift

  # as long as we have `KEY:VALUE' pairs to process
  while (( $# )); do
    # keep everything up to the first `:'
    key=${1%%:*}
    # verify the key conforms to the regex
    if [[ "${key}" =~ $re ]]; then
      # take everything from the first `:' on, and replace in it every
      # `:' by `:.'m thus quoting it.
      reps[${key}]=${1#*:}
      reps[${key}]=${reps[${key}]//:/:.}
    fi
    # go get the next parameter
    shift
  done

  # apply each replacement in turn
  for key in ${!reps[@]}; do
    out="${out//:${key}/${reps[${key}]}}"
  done
  # unquote and return
  printf '%b' "${out//:./:}"
}

# As print(), but always echo a newline
#
# Usage println FORMAT [KEY:VALUE...]
# Returns: 0, always
# Outputs: as print, but with an additional newline at the end
# Depends: print()
println() { print "$@"; echo; }


# ==============================================================================
# == Availability ==============================================================
# ==============================================================================

# Verify the needed commands exist
#
# Usage: verifyNeededCommands
# Returns: 0 if successful, exits with error code 1 if not
# Outputs: error messages to stderr
# Depends: print(), NEEDEDCOMMANDS
#
# taken from <http://wiki.bash-hackers.org/scripting/style#behaviour_and_robustness>
verifyNeededCommands() {
  local -i missing=0
  local comm=''
  # loop through each command
  for comm in "${NEEDEDCOMMANDS[@]}"; do
    # try to hash it (throw away output and errors)
    if ! hash "$comm" &> /dev/null; then
      println $"Command not found in path: \`:missingCommand'" "missingCommand:${comm}"
      (( missing++ )) ||:
    fi
  done
  # show additional error message
  if (( missing )); then
    if (( missing == 1 )); then
      println $"At least one essential command was not found in path!"
    elif (( missing > 1 )); then
      println $"At least :missingAmmount essential commands were not found in path!" "missingAmmount:${missing}"
    fi
    println $"Aborting!"
    exit 1
  fi
}

# ------------------------------------------------------------------------------
# -- Needed commands -----------------------------------------------------------
# ------------------------------------------------------------------------------

# the needed commands
#
# NB: `tput' is not considered "needed" in the strictest sense: its only cosmetical
declare -r NEEDEDCOMMANDS=('cat' 'cut' 'find' 'grep' 'head' 'inotifywait' 'lpr' 'mkdir' 'mkfifo' 'readlink' 'rm' 'sleep' 'sort' 'sudo' 'tail' 'tee' 'tr' 'xargs' 'xinput' 'vboxmanage' 'VirtualBox')


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------


# verify needed bash version
if (( BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2) )); then
  println $"At least bash version 4.2 is needed in order to run this script -- the detected version is \`:major.:minor'" "major:${BASH_VERSINFO[0]}" "minor:${BASH_VERSINFO[1]}"
  println $"Aborting!"
  exit 1
fi

# verify needed commands
verifyNeededCommands


# ==============================================================================
# == Functions =================================================================
# ==============================================================================

# ------------------------------------------------------------------------------
# -- VirtualBox(R) VM functions ------------------------------------------------
# ------------------------------------------------------------------------------

# Get the UUID corresponding to either a name or a UUID
#
# Usage: getUUID { NAME | UUID }
# Returns: 0 if successful, 1 if errors or none found
# Outputs: UUID if found, empty otherwise
# Depends: nothing
getUUID() {
  # use newline as the IFS, since newline is not a valid part of either the UUID
  # nor the name of a VM
  local -r IFS=$'\n'
  # get the list of registered virtual machines, keep only matching names and/or
  # UUIDs, extract the UUIDs and eliminate duplicates
  local -a temp=($(vboxmanage list vms | grep -e "^\"${1}\"" -e "\{${1}\}\$" | grep -oe '\{[[:xdigit:]]\{8\}-[[:xdigit:]]\{4\}-[[:xdigit:]]\{4\}-[[:xdigit:]]\{4\}-[[:xdigit:]]\{12\}\}$' | sort -u))
  # if the denomination is ambiguous, return failure
  if ! (( ${#temp[@]} == 1 )); then return 1; fi
  # remove redundant "{" and "}", echo it and return success
  local -r ret="${temp[0]%\}}"; echo "${ret#\{}"
}

# Get the address associated to a given USB devpath
#
# Usage: devpath2address DEVPATH
# Returns: 0 if successful, 1 if errors or none found
# Outputs: UUID if found, empty otherwise
# Depends: nothing
devpath2address() {
  # use newline as the IFS, since newline is not a valid part of a devpath
  local -r IFS=$'\n'
  # make sure we remove a "/sys" prefix and a "/" suffix from the devpath: we accept
  # it as input, but there's no need for it
  local devpath="${1#/sys}"; devpath="${devpath%/}"; readonly devpath
  # list host usbs, take only the "Address" lines which match the given devpath,
  # take only the actual values of those lines,
  local -ar temp=($(vboxmanage list usbhost | grep -e "^Address:[[:space:]]*sysfs:/sys${devpath}//device:/dev/vboxusb/[[:graph:]]*$" | grep -oe '[^[:space:]]*$'))
  # if we found anything other than a single value, return failure
  if ! (( ${#temp[@]} == 1 )); then return 1; fi
  # echo and return success
  echo "${temp[0]}"
}

# Wait for a virtual machine to be in "running" state
# Initially, wait "INIT_DWELL" seconds, then, every "INT_DWELL" seconds,
# ask for the state of the virtual machine UUID "UUID", up to "MAX_RETRIES"
# times, exiting if the machine in question is not in "starting" state
#
# Usage: waitRunning UUID
# Returns: 0 if successful, 1 if timed out or errors encountered
# Outputs: nothing
# Depends: KBDATTACHINIDWELL, KBDATTACHINTDWELL, KBDATTACHMAXTRIES,
#          ERRPIPE
waitRunning() {
  local  -i i=0
  local -ri l="${KBDATTACHMAXTRIES}"
  # wait initial dwell time
  sleep -- "${KBDATTACHINIDWELL}s"
  for (( i = 0; i < l; i++ )); do
    # get virtual machine's state and exit successfully if "running",
    # unsuccessfully if not in "starting"
    case "$(vboxmanage showvminfo "${1}" --machinereadable 2> "${ERRPIPE}" | grep -e '^VMState=' | cut -d"\"" -f2)" in
      'running') return 0 ;; 'starting') : ;; *) return 1;;
    esac
    # wait internal dwell time
    sleep -- "${KBDATTACHINTDWELL}s"
  done
  # we timed out, too bad
  return 1
}

# Attach USB keyboards
#
# Usage: attachKbds UUID
# Returns: 0 if successful, 1 if errors encountered
# Outputs: nothing
# Depends: devpath2address(), ERRPIPE
attachKbds() {
  local temp=''
  local -i ret=0
  # translate the addresses generated by:
  #   looking under "/sys/bus/usb/devices" for directory links which contain a
  #     "modalias" file such that its contents start with "usb:" and end in
  #     "ic03isc..ip01" (Interface Class == 03, Interface SubClass == whatever,
  #     Interface Protocol == 01),
  #   keep only the path of the parent of the target of such a directory link
  # into UUIDs, and, if said translation is successful, try to attach the
  # USB keyboard in question
  #
  # NB: the "for" is "safe" because there are no syspaths which contain IFS
  for temp in $(find /sys/bus/usb/devices -execdir grep -sq '^usb:.*ic03isc..ip01$' '{}/modalias' ';' -execdir readlink -e '{}/..' ';' | sort -u); do
    # try to get address (ignore errors, we'll check output)
    temp="$(devpath2address "${temp}")" ||:
    # if we got a valid address
    if [[ "${temp}" ]]; then
      # try to attach it (ignore errors, we'll return accordingly)
      vboxmanage controlvm "${1}" usbattach "${temp}" &> "${ERRPIPE}" || (( ret++ )) ||:
    fi
  done
  # if there were errors, return accordingly
  if (( ret )); then return 1; else return 0; fi
}

# ------------------------------------------------------------------------------
# -- VirtualBox(R) misc functions ----------------------------------------------
# ------------------------------------------------------------------------------

# Get the list of SUPPRESSED VirtualBox(R) warnings
#
# Usage: getWarns
# Returns: 0, if successful
# Outputs: a sorted, comma-separated list of values
# Depends: ERRPIPE
getWarns() {
  # get VirtualBox(R)'s warnings (ignoring an unset property), strip the title,
  # turn the comma-separated list into a newline-separated list, remove empty
  # lines, sort it, and turn it back into a comma-separated list
  local -r temp=$(vboxmanage getextradata global 'GUI/SuppressMessages' 2> "${ERRPIPE}" | grep -ve '^No value set!$' | cut -d' ' -f2 | tr ',[:space:]' $'\n' | grep . | sort -u | tr $'\n' ',')
  # remove final comma and echo it
  echo "${temp%,}"
}

# Set the list of SUPPRESSED VirtualBox(R) warnings
#
# Usage: setWarns [WARNING_LIST...]
# Returns: whatever "vboxmanage setextradata GUI/SuppressMessages" does
# Outputs: nothing
# Depends: ERRPIPE
#
# NOTE: WARNING_LIST is a comma-separated list of warnings
setWarns() {
  # turn the comma-separated list into a newline-separated list, remove empty
  # lines, sort it, and turn it back into a comma-separated list
    local -r temp="$(tr ',[:space:]' $'\n' <<< "${*}" | grep . | sort -u | tr $'\n' ',')"
  # set them
  vboxmanage setextradata global 'GUI/SuppressMessages' "${temp%,}" 2> "${ERRPIPE}"
}

# ------------------------------------------------------------------------------
# -- Lock functions ------------------------------------------------------------
# ------------------------------------------------------------------------------

# Try to get a lock on the lockfile
# If successful the lockfile will contain the PID of the calling process
# toghether with any additional strings provided
#
# Usage: getLock [STRING...]
# Returns: 0 if successfully acquired lock, 1 otherwise
# Outputs: nothing if successful, the PID of the locking process otherwise
# Depends: LOCKFILE, LOCKRETRIES, ERRPIPE
#
# NOTE: this functions does NOT provide for error hardening, you need
#       to set traps and remember to remove the lock yourself
getLock() {
  local -i otherPID=0
  local -i i=0
  # try at most "LOCKRETRIES" times
  for (( i = 0; i < LOCKRETRIES; i++ )); do
    # try to get lock by using the noclobber option
    if (set -o noclobber; IFS=':'; echo "$$:${*}" > "${LOCKFILE}" 2> "${ERRPIPE}"); then return 0; fi
    # get the locking PID (mask errors, in the VERY unlikely case of the
    # file being removed prior to this)
    otherPID=$(head -n1 -- "${LOCKFILE}" 2> "${ERRPIPE}" | cut -d':' -f1 2> "${ERRPIPE}") ||:
    # check for stale
    if (( otherPID )) && kill -0 -- "${otherPID}" 2> "${ERRPIPE}"; then
      # the lock is effectively being held by a running process,
      # echo the locking PID and return error
      #
      # NOTE: this does NOT mean that the running process "holding" the
      #       lock is actually a vbht instance, just that there's one
      #       with such a PID running
      echo "${otherPID}"; return 1
    fi
    # the process holding the lock is dead, remove lock...
    rm -f -- "${LOCKFILE}" 2> "${ERRPIPE}"
  done
  # return failure
  return 1
}

# Add a line to the lockfile
#
# Usage: addToLock [STRING...]
# Returns: 0 if ok, nonzero on errors
# Outputs: nothing
# Depends: LOCKFILE, ERRPIPE
addToLock() {
  # locally use ':' as IFS, and append to the lockfile
  local -r IFS=':'; echo "$$:${*}" >> "${LOCKFILE}" 2> "${ERRPIPE}"
}

# Read the contents of the lockfile
# Read the LAST line in the lockfile; use the last line, as the lockfile
# may have been added to
#
# Usage: readLock [VAR...]
# Returns: 0 if successful, 1 if there's no lockfile
# Outputs: nothing, but it modifies the values of the given variables as
#          the "read" builtin would
# Depends: LOCKFILE, ERRPIPE
readLock() {
  # try to read the given variables
  IFS=':' read -r ${@} < <(tail -n1 -- "${LOCKFILE}" 2> "${ERRPIPE}" ||:)
}

# ------------------------------------------------------------------------------
# -- Peripheral functions ------------------------------------------------------
# ------------------------------------------------------------------------------

# Disable (every) keyboard and mouse
#
# Usage: disableKbdsMice [XID_LIST...]
# Returns: 0, always
# Outputs: a sorted, comma-separated list of disabled XIDs
# Depends: ERRPIPE
#
# NOTE: XID_LIST is a comma-separated list of XIDs
disableKbdsMice() {
  local xids=''
  # if no XIDs given, get them all
  if ! (( $# )); then
    # get the list slave keyboard and pointer XIDs, sort them, and
    # concatenate them into a comma-terminated list of XIDs
    xids="$(xinput list 2> "${ERRPIPE}" | grep -e 'slave[[:space:]]\+keyboard' -e 'slave[[:space:]]\+pointer' | grep -ve 'XTEST' | grep -oe 'id=[[:digit:]]\+' | cut -d'=' -f2 | sort -ug | tr $'\n' ',')"
    xids="${xids%,}"
  else
    # otherwise, just set xids
    xids="${*}"
  fi
  # sort the given XIDs, and, on the one hand, disable them, and on the
  # other concatenate them into a comma-terminated list of XIDs
  # @DEBUG: xids="$(tr ',[:space:]' $'\n' <<< "${xids}" | grep . | sort -ug | tee >(xargs -rn1 -IX echo xinput set-prop 'X' 'Device Enabled' 0 &> "${ERRPIPE}") | tr $'\n' ',')"
  xids="$(tr ',[:space:]' $'\n' <<< "${xids}" | grep . | sort -ug | tee >(xargs -rn1 -IX xinput set-prop 'X' 'Device Enabled' 0 &> "${ERRPIPE}") | tr $'\n' ',')"
  # output the list
  echo "${xids%,}"
}

# Enable (every) keyboard and mouse
#
# Usage: enableKbdsMice [XID_LIST...]
# Returns: 0, always
# Outputs: a sorted, comma-separated list of enabled XIDs
# Depends: ERRPIPE
#
# NOTE: XID_LIST is a comma-separated list of XIDs
enableKbdsMice() {
  local xids=''
  # if no XIDs given, get them all
  if ! (( $# )); then
    # get the list slave keyboard and pointer XIDs, sort them, and
    # concatenate them into a comma-terminated list of XIDs
    xids="$(xinput list 2> "${ERRPIPE}" | grep -e 'slave[[:space:]]\+keyboard' -e 'slave[[:space:]]\+pointer' | grep -ve 'XTEST' | grep -oe 'id=[[:digit:]]\+' | cut -d'=' -f2 | sort -ug | tr $'\n' ',')"
    xids="${xids%,}"
  else
    # otherwise, just set xids
    xids="${*}"
  fi
  # sort the given XIDs, and, on the one hand, enable them, and on the
  # other concatenate them into a comma-terminated list of XIDs
  # @DEBUG: xids="$(tr ',[:space:]' $'\n' <<< "${xids}" | grep . | sort -ug | tee >(xargs -rn1 -IX echo xinput set-prop 'X' 'Device Enabled' 1 &> "${ERRPIPE}") | tr $'\n' ',')"
  xids="$(tr ',[:space:]' $'\n' <<< "${xids}" | grep . | sort -ug | tee >(xargs -rn1 -IX xinput set-prop 'X' 'Device Enabled' 1 &> "${ERRPIPE}") | tr $'\n' ',')"
  # output the list
  echo "${xids%,}"
}

# ------------------------------------------------------------------------------
# -- Trap functions ------------------------------------------------------------
# ------------------------------------------------------------------------------

# Execute a DEBUG trap
#
# Usage: debugTrap BASH_COMMAND FUNCNAME LINENO
# Returns: 0, always
# Outputs: nothing
# Depends: DO_TRAP_LOGGING, logDebug()
debugTrap() {
  if [[ "${DO_TRAP_LOGGING:-N}" != 'N' && "${2}" != 'log' && "${2}" != 'errListener' && "${2}" != 'exitTrap' ]]; then
    logDebug $"Running \`:command' at \`:function:.:line'" "command:${1}" "function:${2:-main}" "line:${3}"
  fi
}

# Execute a EXIT (and ERR) trap
#
# Usage: exitTrap
# Returns: 0, always
# Outputs: nothing
# Depends: PNPID, PLPID, ELPID, PRNPIPE, ERRPIPE
exitTrap() {
  # kill printNotifier
  if [[ ${PNPID:-} ]]; then kill "${PNPID}" &> /dev/null ||: ; fi
  # kill printListener
  if [[ ${PLPID:-} ]]; then kill "${PLPID}" &> /dev/null ||: ; fi
  # kill errlistener
  if [[ ${ELPID:-} ]]; then kill "${ELPID}" &> /dev/null ||: ; fi
  # remove lock file (if we launched a VM)

  # remove print pipe
  rm -f -- "${PRNPIPE}" &> /dev/null
  # remove error pipe
  rm -f -- "${ERRPIPE}" &> /dev/null
}

# ------------------------------------------------------------------------------
# -- Log functions -------------------------------------------------------------
# ------------------------------------------------------------------------------

# Write to the logfile and, optionally, to stderr
# Write the provided arguments to the LOGFILE, assuming a given SEVERITY
# and, depending on the value of "verbosity", output STRING... to stderr
# using a `print'-life format.
#
# Usage: log SEVERITY FORMAT [PARAMS...]
# Returns: 0, always
# Outputs: depending on settings, it may output STRING... to stderr
# Depends: print(), verbosity, LOGFILE, SEV_FATAL, SEV_ERROR, SEV_WARNING,
#          SEV_INFO, SEV_DEBUG, SEV_STDERR, START_FATAL, STOP_FATAL,
#          START_ERROR, STOP_ERROR, START_WARNING, STOP_WARNING,
#          START_INFO, STOP_INFO, START_DEBUG, STOP_DEBUG, START_STDERR,
#          STOP_STDERR, prevRUNHASH, RUNHASH, ERRPIPE
log() {
  # get severity (declare severity "name" too)
  local -ri severity="${1}"
  local -u  sev_name=''
  # set up temporaries
  local std_err=''
  local std_log=''

  # prepend severity type string to output line (don't do anything for
  # unrecognised severities) and build stderr and stdlog temporaries
  if   (( severity == SEV_FATAL   )); then sev_name='F'; std_err="${START_FATAL}"$"Fatal"":${STOP_FATAL}"      ; std_log=$"Fatal"':'
  elif (( severity == SEV_ERROR   )); then sev_name='E'; std_err="${START_ERROR}"$"Error"":${STOP_ERROR}"      ; std_log=$"Error"':'
  elif (( severity == SEV_WARNING )); then sev_name='W'; std_err="${START_WARNING}"$"Warning"":${STOP_WARNING}"; std_log=$"Warning"':'
  elif (( severity == SEV_INFO    )); then sev_name='I'; std_err="${START_INFO}"$"Info"":${STOP_INFO}"         ; std_log=$"Info"':'
  elif (( severity == SEV_DEBUG   )); then sev_name='D'; std_err="${START_DEBUG}"$"Debug"":${STOP_DEBUG}"      ; std_log=$"Debug"':'
  elif (( severity == SEV_STDERR  )); then sev_name='S'; std_err="${START_STDERR}"$"Stderr"":${STOP_STDERR}"   ; std_log=$"Stderr"':'
  else                                     sev_name='O'
  fi
  # fill stderr and stdlog temporaries up with print output
  std_err="${std_err} $(print "${2}" "${@:3}" 2> "${ERRPIPE}")"
  std_log="${std_log} $(print "${2}" "${@:3}" 2> "${ERRPIPE}")"

  # if verbosity mandates, show to stderr
  if (( severity <= verbosity )); then echo "${std_err}" >&2; fi
  # write to the log file
  echo "[${RUNHASH}-$(printf '%(%Y:%m:%d:%H:%M:%S:%z)T' -1)-${sev_name}] ${std_log}" >> "${LOGFILE}"
}

# Call log() with the appropriate severity
#
# Usage: logFatal     FORMAT [PARAMS...]
#        logError     FORMAT [PARAMS...]
#        logWarning   FORMAT [PARAMS...]
#        logInfo      FORMAT [PARAMS...]
#        logDebug     FORMAT [PARAMS...]
#        logStderr    FORMAT [PARAMS...]
#        logOtherVerb FORMAT [PARAMS...]
#        logOtherSlnt FORMAT [PARAMS...]
# Returns: 0, always
# Outputs: depending on settings, it may output STRING... to stderr
# Depends: LOGFILE, SEV_FATAL, SEV_ERROR, SEV_WARNING, SEV_INFO, SEV_DEBUG,
#          SEV_STDERR, log()
logFatal()     { log ${SEV_FATAL}      "$@"; }
logError()     { log ${SEV_ERROR}      "$@"; }
logWarning()   { log ${SEV_WARNING}    "$@"; }
logInfo()      { log ${SEV_INFO}       "$@"; }
logDebug()     { log ${SEV_DEBUG}      "$@"; }
logStderr()    { log ${SEV_STDERR}     "$@"; }
logOtherVerb() { log ${SEV_OTHER_VERB} "$@"; }
logOtherSlnt() { log ${SEV_OTHER_SLNT} "$@"; }

# ------------------------------------------------------------------------------
# -- Duplex functions ----------------------------------------------------------
# ------------------------------------------------------------------------------

# Listen to stderr pipe and log
#
# Continuously read from ERRPIPE and log whatever gets read as SEV_STDERR
#
# Usage errListener [&]
# Returns: 0, always
# Outputs: nothing
# Depends: logStderr(), ERRPIPE
errListener() {
  # set up temporary
  local line=''
  # while there's a (raw) line to be read
  while IFS= read -r line; do
    # if it's not blank, log it with SEV_STDERR
    # IMPORTANT: REPLACE ':' WITH ':.' IN ORDER FOR PRINT NOT TO CHOKE
    if [[ "${line}" ]]; then logStderr "${line//:/:.}"; fi
  # use RW redirection to avoid blocking on open (http://stackoverflow.com/a/6448737)
  done <> "${ERRPIPE}"
}

# Start print-listening on the given directory in the background
# The given PRINTDIR is created (if not already existing), and, upon file
# creation, the file in question is fed to "lpr" for printing; the printListener
# will commit suicide if PRINTDIR is erased (and is the ONLY way of safely
# and cleanly terminating the printListener).
# Usage: printListener [&]
# Returns: 1 in case of errors, IT DOES NOT RETURN IF SUCCESSFUL (it will be
#          listening for files to print, no time to return at all); thus the
#          preferred background terminator in "Usage"
# Outputs: nothing
# Depends: logError(), PRINTDIR
#
# Taken from: https://github.com/rvoicilas/inotify-tools/issues/5#issuecomment-17756009
printListener() {
  # set up temporary
  local -u temp=''
  local file=''
  # while there's a (raw) line to be read
  while IFS= read -r file; do
    # verify we actually have a (readable) file
    if ! [[ -r "${PRINTDIR}/${file}" ]]; then continue; fi
    # verify the file is actually a PDF one
    temp=${file:(-4)}; if [[ "${temp}" == '.PDF' ]]; then
      # print the recently created file without a banner and deleting it
      # when done (if there are errors, log them)
      (
        if ! lpr -hr "${PRINTDIR}/${file}"; then
          logError $"lpr returned non-zero (:status) status" "status:$?"
        else
          rm -f -- "${PRINTDIR}/${file}"
        fi
      ) & disown %1
    else
      # otherwise, just remove it, we don't care for it
      rm -f "${PRINTDIR}/${file}" &> "${ERRPIPE}"
    fi
  # use RW redirection to avoid blocking on open (http://stackoverflow.com/a/6448737)
  done <> "${PRNPIPE}"
}


# ==============================================================================
# == Messaging functions =======================================================
# ==============================================================================

# Display the main help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showHelp() {
  print $"\
Usage: vbht start { UUID | NAME } [ -AaKkRrPpXx ]
               [ --auto-attach ]    [ --no-auto-attach ]
               [ --kbd-attach ]     [ --no-kbd-attach ]
               [ --acpi-forward ]   [ --no-acpi-forward ]
               [ --print-listener ] [ --no-print-listener ]
               [ --new-X ]          [ --no-new-X ]
               { DEVPATH | FOLDERSPEC ...}
   or: vbht attach [ -f ] [ --force ] { DEVPATH | FOLDERSPEC ...}
   or: vbht info [ -Mm ] [ --machine-readable ] [ --no-machine-readable ]
   or: vbht logs [ -FfEeWwIiDdSs ]
               [ --show-fatal ]   [ --no-show-fatal ]
               [ --show-error ]   [ --no-show-error ]
               [ --show-warning ] [ --no-show-warning ]
               [ --show-info ]    [ --no-show-info ]
               [ --show-debug ]   [ --no-show-debug ]
               [ --show-stderr ]  [ --no-show-stderr ]
               { UUID | NAME | HASH | - ...}
   or: vbht stop [ -aorsl ] [ -f ] [ --force ]
               [ --acpi | --off | --reset | --save | --sleep ]

common options: [ -qv ] [ --quiet ] [ --verbose ] [--]

   or: vbht { -h | --help }
   or: vbht { -V | --version }
   or: vbht { -L | --license }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

      -A, --auto-attach        automatically attach USB devices plugged in
                               during the operation of the virtual machine,
                               additionally, allow them to be attached through
                               vbht
      -a, --no-auto-attach     do NOT automatically attach USB devices plugged
                               in during the operation of the virtual machine,
                               nor permit them to be attached through vbht
      -K, --kbd-attach         try to attach USB keyboards
      -k, --no-kbd-attach      do NOT try to attach USB keyboards
      -F, --acpi-forward       forward ACPI power-button / sleep-button events
                               to the virtual machine
      -f, --no-acpi-forward    don't try to forward ACPI events to the virtual
                               machine
      -P, --print-listener     run the print listening script
      -p, --no-print-listener  do NOT run the print listening script
      -X, --new-X              launch a fresh X server
      -x, --no-new-X           do NOT launch a fresh X server

      -M, --machine-readable     generate output in machine readable format
      -m, --no-machine-readable  generate output in human readable format

      -F, --show-fatal       show \`fatal' log lines
      -f, --no-show-fatal    do NOT show \`fatal' log lines
      -E, --show-error       show \`error' log lines
      -e, --no-show-error    do NOT show \`error' log lines
      -W, --show-warning     show \`warning' log lines
      -w, --no-show-warning  do NOT show \`warning' log lines
      -I, --show-info        show \`info' log lines
      -i, --no-show-info     do NOT show \`info' log lines
      -D, --show-debug       show \`debug' log lines
      -d, --no-show-debug    do NOT show \`debug' log lines
      -S, --show-stderr      show \`stderr' log lines
      -s, --no-show-stderr   do NOT show \`stderr' log lines

      -a, --acpi   send ACPI poweroff signal to the capturing virtual machine
      -o, --off    turn the capturing virtual machine off
      -r, --reset  reset the capturing virtual machine
      -s, --save   save the capturing virtual machine's state
      -l, --sleep  send ACPI sleep signal to the capturing virtual machine

      -f, --force  forcibly attach the given DEVPATH or FOLDERSPEC, even if
                   the machine is not accepting auto attachments
                   OR
                   force the ACPI event to be sent, even if the machine is not
                   being forwarded ACPI events, ignored if stoppage type is
                   not one of \`acpi' or \`sleep'
                   
      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      --  signal the end of options, lake the rest of the parameters literally

      -h, --help     display this help and exit
      -V, --version  output version information and exit
      -L, --license  display the GNU Affero General Public License and exit

Actions: the first argument to vbht must be either \`--help', \`--version',
  \`--license', or an ACTION, ie. one of: \`start', \`attach', \`info',
  \`logs', or \`stop'.

      start    start the virtual machine NAME or UUID in capturing mode
      attach   attach the (USB) device found at each DEVPATH to the virtual
               machine currently running in capturing mode, or each FOLDERSPEC
               to its corresponding shared folder
      info     return information about the virtual machine currently running
               in capturing mode (if there's one such machine)
      logs     show (coloured) log files for the given virtual machine, or for
               the currently running one, if there's one such and \`-' given
      stop     stop the virtual machine currently running in capturing mode

Verbosity: the 6 verbosity levels are \`fatal', \`error', \`warning', \`info',
  \`debug', and \`stderr'.

      fatal    a condition which makes it impossible to go on
      error    an error condition that can be ignored in order to go on
      warning  an error condition that has no immediate consequences
      info     an informational message about the state of the program
      debug    an execution log of every command ran
      stderr   the standard error lines, as redirected internally

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: \`VBHT_AUTO_ATTACH', \`VBHT_ATTACH_KEYBOARD',
  \`VBHT_ACPI_FORWARD', \`VBHT_LAUNCH_PRINT_LISTENER', \`VBHT_USE_NEW_X',
  \`VBHT_INFO_MACHINE_READABLE', \`VBHT_FORCE_STOP', and \`VBHT_FORCE_ATTACH' can
  take either the \`Y' or \`N' values and provide defaults for their corresponding
  options; the \`VBHT_STOP_METHOD' variable can take either one of the \`A', \`O',
  \`R', \`S', \`L' values and each determines a stoppage type whose equivalence to
  the options mentioned above is given by:

      A  -a, --acpi
      O  -o, --off
      R  -r, --reset
      S  -s, --save
      L  -l, --sleep

  last, the \`VBHT_VERBOSITY' variable may take any integer number to be taken
  as the default verbosity value (note, however, that values below 0 or above 6
  will be ignored and truncated to that range).

Examples (\`>' stands for the shell prompt):

    > vbht start 'My VM' --no-print-listener --no-auto-attach

    > vbht attach /devices/pci0123:.45/6789:.01:.23.4/usb5/6-7

    > vbht info --machine-readable
    12345:.67890:.01234567-89ab-cdef-0123-4567890abcde:.HASH:.N:.Y:.N:.Y:.Y

    > vbht stop --acpi

Exit status:
   0  if OK,
   1  if syntax error,
   2  if no capturing virtual machines found.


NOTES:
  1. if more than one conflicting option is given the last one takes precedence
     (this does NOT apply to verbosity options),
  2. the DEVPATH arguments have the same syntax as udev's \`\$devpath' or \`%p'
     replaceable parameter (see UDEV(7)),
  3. the FOLDERSPEC arguments are of either of the forms: \`NAME@PATH' or
     \`NAME#PATH'; the first one specifies a shared folder referring to \`PATH' and
     being called \`NAME' inside the virtual machine, the second one is similar,
     except that it specifies a READ-ONLY folder.
     Together with DEVPATHs, they're collectively referred to as ATTACHSPECs.
  4. You can use \`:vbhtName ACTION --help' to get detailed help for the given
     action.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}

# Display the version message
#
# Usage: showVersion
# Returns: 0, always
# Outputs: version text
# Depends: print()
showVersion() {
  print $"\
vbht 0.3
Copyright (C) 2012 Mariano Perez Rodriguez
License AGPLv3+: GNU AGPL version 3 or later <http://gnu.org/licenses/agpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
"
}

# Display the `start' help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showStartHelp() {
print $"\
Usage: vbht start { UUID | NAME } [ -AaKkRrPpXx ]
               [ --auto-attach ]    [ --no-auto-attach ]
               [ --kbd-attach ]     [ --no-kbd-attach ]
               [ --acpi-forward ]   [ --no-acpi-forward ]
               [ --print-listener ] [ --no-print-listener ]
               [ --new-X ]          [ --no-new-X ]
               { DEVPATH | FOLDERSPEC ...}

common options: [ -qv ] [ --quiet ] [ --verbose ] [--]

   or: vbht start { -h | --help }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

Action \`start' starts the virtual machine NAME or UUID in capturing mode, then
it proceeds to attach every ATTACHSPEC given.

      -A, --auto-attach        automatically attach USB devices plugged in
                               during the operation of the virtual machine,
                               additionally, allow them to be attached through
                               vbht
      -a, --no-auto-attach     do NOT automatically attach USB devices plugged
                               in during the operation of the virtual machine,
                               nor permit them to be attached through vbht
      -K, --kbd-attach         try to attach USB keyboards
      -k, --no-kbd-attach      do NOT try to attach USB keyboards
      -F, --acpi-forward       forward ACPI power-button / sleep-button events
                               to the virtual machine
      -f, --no-acpi-forward    don't try to forward ACPI events to the virtual
                               machine
      -P, --print-listener     run the print listening script
      -p, --no-print-listener  do NOT run the print listening script
      -X, --new-X              launch a fresh X server
      -x, --no-new-X           do NOT launch a fresh X server

      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      --  signal the end of options, lake the rest of the parameters literally

      -h, --help  display this help and exit

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: \`VBHT_AUTO_ATTACH', \`VBHT_ATTACH_KEYBOARD',
  \`VBHT_ACPI_FORWARD', \`VBHT_LAUNCH_PRINT_LISTENER', \`VBHT_USE_NEW_X', can
  take either the \`Y' or \`N' values and provide defaults for their corresponding
  options; the \`VBHT_VERBOSITY' variable may take any integer number to be taken
  as the default verbosity value (note, however, that values below 0 or above 6
  will be ignored and truncated to that range).

Examples (\`>' stands for the shell prompt):

    > vbht start 'My VM' --no-print-listener --no-auto-attach

    > vbht start 'My VM' /devices/pci0123:.45/6789:.01:.23.4/usb5/6-7 home@~

Exit status:
   0  if OK,
   1  if syntax error,

NOTES:
  1. if more than one conflicting option is given, the last one takes precedence
     (this does NOT apply to verbosity options),
  2. the DEVPATH arguments have the same syntax as udev's \`\$devpath' or \`%p'
     replaceable parameter (see UDEV(7)),
  3. the FOLDERSPEC arguments are of either of the forms: \`NAME@PATH' or
     \`NAME#PATH'; the first one specifies a shared folder referring to \`PATH' and
     being called \`NAME' inside the virtual machine, the second one is similar,
     except that it specifies a READ-ONLY folder.
     Together with DEVPATHs, they're collectively referred to as ATTACHSPECs.
  4. You can use \`:vbhtName --help' to get more general help.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}

# Display the `attach' help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showAttachHelp() {
  print $"\
Usage: vbht attach [ -f ] [ --force ] { DEVPATH | FOLDERSPEC ...}

common options: [ -qv ] [ --quiet ] [ --verbose ] [--]

   or: vbht attach { -h | --help }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

Action \`attach' attaches the (USB) devices found at each DEVPATH to the virtual
machine currently running in capturing mode, or each FOLDERSPEC to its
corresponding shared folder.

      -f, --force  forcibly attach the given DEVPATH or FOLDERSPEC, even if
                   the machine is not accepting auto attachments
                   
      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      --  signal the end of options, lake the rest of the parameters literally

      -h, --help     display this help and exit

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: \`VBHT_FORCE_ATTACH' can take either the \`Y' or
  \`N' values and provides a default for its corresponding option; the
  \`VBHT_VERBOSITY' variable may take any integer number to be taken as the
  default verbosity value (note, however, that values below 0 or above 6 will be
  ignored and truncated to that range).

Examples (\`>' stands for the shell prompt):

    > vbht attach /devices/pci0123:.45/6789:.01:.23.4/usb5/6-7 home#~

Exit status:
   0  if OK,
   1  if syntax error,
   2  if no capturing virtual machines found.


NOTES:
  1. if more than one conflicting option is given (eg. more than one stop type),
     the last one takes precedence (this does NOT apply to verbosity options),
  2. the DEVPATH arguments have the same syntax as udev's \`\$devpath' or \`%p'
     replaceable parameter (see UDEV(7)).
  3. the FOLDERSPEC arguments are of either of the forms: \`NAME@PATH' or
     \`NAME#PATH'; the first one specifies a shared folder referring to \`PATH' and
     being called \`NAME' inside the virtual machine, the second one is similar,
     except that it specifies a READ-ONLY folder.
     Together with DEVPATHs, they're collectively referred to as ATTACHSPECs.
  4. You can use \`:vbhtName --help' to get more general help.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}

# Display the `info' help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showInfoHelp() {
  print $"\
Usage: vbht info [ -Mm ] [ --machine-readable ] [ --no-machine-readable ]

common options: [ -qv ] [ --quiet ] [ --verbose ]

   or: vbht { -h | --help }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

Action \`info' returns information about the virtual machine currently running
in capturing mode (if there's one such machine).

      -M, --machine-readable     generate output in machine readable format
      -m, --no-machine-readable  generate output in human readable format
                   
      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      -h, --help     display this help and exit

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: \`VBHT_INFO_MACHINE_READABLE' can take either the
  \`Y' or \`N' values and provides a default for its corresponding option; the
  \`VBHT_VERBOSITY' variable may take any integer number to be taken as the default
  verbosity value (note, however, that values below 0 or above 6 will be ignored
  and truncated to that range).

Examples (\`>' stands for the shell prompt):

    > vbht info --machine-readable
    12345:.67890:.01234567-89ab-cdef-0123-4567890abcde:.HASH:.N:.Y:.N:.Y:.Y

Exit status:
   0  if OK,
   1  if syntax error,
   2  if no capturing virtual machines found.


NOTES:
  1. if more than one conflicting option is given the last one takes precedence
     (this does NOT apply to verbosity options),
  4. You can use \`:vbhtName --help' to get more general help.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}

# Display the `logs' help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showLogsHelp() {
  print $"\
Usage: vbht logs [ -FfEeWwIiDdSs ]
               [ --show-fatal ]   [ --no-show-fatal ]
               [ --show-error ]   [ --no-show-error ]
               [ --show-warning ] [ --no-show-warning ]
               [ --show-info ]    [ --no-show-info ]
               [ --show-debug ]   [ --no-show-debug ]
               [ --show-stderr ]  [ --no-show-stderr ]
               { UUID | NAME | HASH | - ...}

common options: [ -qv ] [ --quiet ] [ --verbose ]

   or: vbht { -h | --help }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

Action \`logs' shows (coloured) log files for the given virtual machine, or for
the currently running one, if there's one such and \`-' given.

      -F, --show-fatal       show \`fatal' log lines
      -f, --no-show-fatal    do NOT show \`fatal' log lines
      -E, --show-error       show \`error' log lines
      -e, --no-show-error    do NOT show \`error' log lines
      -W, --show-warning     show \`warning' log lines
      -w, --no-show-warning  do NOT show \`warning' log lines
      -I, --show-info        show \`info' log lines
      -i, --no-show-info     do NOT show \`info' log lines
      -D, --show-debug       show \`debug' log lines
      -d, --no-show-debug    do NOT show \`debug' log lines
      -S, --show-stderr      show \`stderr' log lines
      -s, --no-show-stderr   do NOT show \`stderr' log lines

      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      -h, --help     display this help and exit

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: the \`VBHT_VERBOSITY' variable may take any
  integer number to be taken as the default verbosity value (note, however, that
  values below 0 or above 6 will be ignored and truncated to that range).

Exit status:
   0  if OK,
   1  if syntax error,
   2  if no capturing virtual machines found.


NOTES:
  1. if more than one conflicting option is given the last one takes precedence
     (this does NOT apply to verbosity options),
  4. You can use \`:vbhtName --help' to get more general help.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}

# Display the `stop' help message
#
# Usage: showHelp
# Returns: 0, always
# Outputs: main help text
# Depends: print()
showStopHelp() {
  print $"\
Usage: vbht stop [ -aorsl ] [ -f ] [ --force ]
               [ --acpi | --off | --reset | --save | --sleep ]

common options: [ -qv ] [ --quiet ] [ --verbose ]

   or: vbht { -h | --help }

Launch, manage, query and stop VirtualBox(R) virtual machines in \`capturing'
mode, thus effectively implementing \`kiosk mode', allowing for transparent
printing, keyboard jailing, and USB auto-attachment.

Action \`stop' stops the virtual machine currently running in capturing mode.

      -a, --acpi   send ACPI poweroff signal to the capturing virtual machine
      -o, --off    turn the capturing virtual machine off
      -r, --reset  reset the capturing virtual machine
      -s, --save   save the capturing virtual machine's state
      -l, --sleep  send ACPI sleep signal to the capturing virtual machine

      -f, --force  forcibly attach the given DEVPATH or FOLDERSPEC, even if
                   the machine is not accepting auto attachments
                   OR
                   force the ACPI event to be sent, even if the machine is not
                   being forwarded ACPI events, ignored if stoppage type is
                   not one of \`acpi' or \`sleep'
                   
      -q, --quiet    decrease by 1 the verbosity level
      -v, --verbose  increase by 1 the verbosity level

      -h, --help     display this help and exit

Environment variables: several environment variables, with the \`VBHT_' prefix,
  are used to provide defaults: \`VBHT_FORCE_STOP' can take either the \`Y' or
  \`N' values and provides a default for its corresponding option; the
  \`VBHT_STOP_METHOD' variable can take either one of the \`A', \`O', \`R', \`S',
  \`L' values and each determines a stoppage type whose equivalence to the
  options mentioned above is given by:

      A  -a, --acpi
      O  -o, --off
      R  -r, --reset
      S  -s, --save
      L  -l, --sleep

  last, the \`VBHT_VERBOSITY' variable may take any integer number to be taken
  as the default verbosity value (note, however, that values below 0 or above 6
  will be ignored and truncated to that range).

Examples (\`>' stands for the shell prompt):

    > vbht stop --acpi

    > vbht stop -f --acpi

Exit status:
   0  if OK,
   1  if syntax error,
   2  if no capturing virtual machines found.


NOTES:
  1. if more than one conflicting option is given the last one takes precedence
     (this does NOT apply to verbosity options),
  4. You can use \`:vbhtName --help' to get more general help.


Written by Mariano Perez Rodriguez.
Report vbht bugs to: <mariano.perez.rodriguez@gmail.com>
" "vbhtName:${0##*/}"
}


# ==============================================================================
# == Actual work functions =====================================================
# ==============================================================================

# ------------------------------------------------------------------------------
# -- Start ---------------------------------------------------------------------
# ------------------------------------------------------------------------------

# Perform the `start' action
#
# Usage: doStart
# Returns: 0, always
# Outputs: depends
# Depends:
doStart() {
  #
  # vmUUID: user provided UUID or name
  # $@: DEVPATHs to attach on init
  #
  # auto_attach          : 'Y' / 'N'
  # attach_keyboard      : 'Y' / 'N'
  # acpi_forward         : 'Y' / 'N'
  # launch_print_listener: 'Y' / 'N'
  # use_new_X            : 'Y' / 'N'
  #

  # set common variables
  vmUID="${UID}"
  # verify that vmUUID refers to an actual virtual machine (mask errors,
  # we're going to check for emptiness of "vmUUID")
  temp="${vmUUID}"; vmUUID=$(getUUID ${vmUUID}) ||:
  # fail if not a valid virtual machine specification
  if ! [[ "${vmUUID}" ]]; then logError $"invalid virtual machine specification! -- \`:specification'" "specification:${temp}"; errors='X'
  else
    # try to get lock (mask errors, we're going to check the output)
    lockingPID="$(getLock "${vmUID}" "${vmUUID}" "${RUNHASH}" "${auto_attach}" "${attach_keyboard}" "${acpi_forward}" "${launch_print_listener}" "${use_new_X}")" ||:
    # if there's another process using the lock, fail
    if (( lockingPID )); then logError $"another process is holding the lock with PID :lockingPID!" "lockingPID:${lockingPID}"; errors='X'
    else
      # save VirtualBox(R)'s ignored warnings
      warns="$(getWarns)"
      # try to set ignored warnings, and fail if we couldn't
      if ! setWarns "${IGNOREWARNINGS}"; then
        logError $"setting ignored warnings returned non-zero (:status) status, keyboard attachment disabled!" "status:$?"; errors='X'
        # if warnings could not be disabled, disable keyboard attachment
        attach_keyboard='E'
        # tell the lockfile about it
        addToLock "${vmUID}" "${vmUUID}" "${RUNHASH}" "${auto_attach}" "${attach_keyboard}" "${acpi_forward}" "${launch_print_listener}" "${use_new_X}"
      fi

      # if we have to launch the print listener, do that now
      if [[ "${launch_print_listener}" == 'Y' ]]; then
        # create the print directory if not already existing
        mkdir -p "${PRINTDIR}"
        # launch the print notifier in background
        inotifywait -qme close_write --format '%f' -- "${PRINTDIR}" > "${PRNPIPE}" 2> "${ERRPIPE}" & PNPID=$!
      fi

      # if we're going to attach keyboards disable input devices now
      # (in order to avoid unusable virtual machines)
      if [[ "${attach_keyboard}" == 'Y' ]]; then
        # try to disable input devices
        ret=0; indevs="$(disableKbdsMice)" || ret=$?
        if (( ret )); then
          # if disabling failed, yell
          logError $"disabling input devices (:inputDeviceList) failed, keyboards will NOT be attached!" "inputDeviceList:${indevs}"; errors='X'
          attach_keyboard='E'
          # tell the lockfile about it
          addToLock "${vmUID}" "${vmUUID}" "${RUNHASH}" "${auto_attach}" "${attach_keyboard}" "${acpi_forward}" "${launch_print_listener}" "${use_new_X}"
        fi
      fi

      # start building launch line
      line="VirtualBox --startvm '${vmUUID}'"
      # prepend it with the "openx" wrapper if a new instance of the X server is
      # to be run, additionally, add a "--fullscreen" modifier
      if [[ "${use_new_X}" == 'Y' ]]; then line="sudo -Hn -- /opt/vbht/openx -n ${line} --fullscreen"; fi
      # finish building launch line
      line="${line} --no-debug --no-startvm-errormsgbox --start-running 2> ${ERRPIPE}"
      # evaluate launch line (no point in checking exit code, as the line is run
      # in the background) and get its PID
      eval -- "${line}" & vbPID=$!
      # let the log know about this
      log ${SEV_OTHER_SLNT} "STARTED ${vmUUID}"

      # wait for the VM to become available, recover if it timed out
      if ! waitRunning "${vmUUID}"; then
        logWarning $"could not wait for virtual machine to start up, keyboard attachment will NOT be available!"; errors='X'
        # disable keyboard attachment
        attach_keyboard='E'
        # tell the lockfile about it
        addToLock "${vmUID}" "${vmUUID}" "${RUNHASH}" "${auto_attach}" "${attach_keyboard}" "${acpi_forward}" "${launch_print_listener}" "${use_new_X}"
      fi

      # machine is in "running" state, attach keyboards if need be
      if [[ "${attach_keyboard}" == 'Y' ]]; then
        # try to attach every keyboard, and, if there were errors, just yell, not much we can do now
        if ! attachKbds "${vmUUID}"; then logError $"keyboard attachment failed for at least one device!"; errors='X'; fi
      fi

      # if there are ATTACHSPECs to attach, do that now
      force_attachment='Y' doAttach

      # if we disabled input devices, re-enable them now
      if [[ "${indevs}" ]]; then
        # try to re-enable input devices
        if ! enableKbdsMice "${indevs}" &> "${ERRPIPE}"; then
          # if re-enabling failed, yell and try to re-enable all of them
          logError $"re-enabling input devices failed, trying to re-enable them all!"; errors='X'
          if ! enableKbdsMice &> "${ERRPIPE}"; then logError $"re-enabling all input devices failed!"; errors='X'; fi
        fi
      fi

      # wait for the virtual machine to finish (or be finished)
      wait "${vbPID}"

      # try to restore ignored warnings, if the command failed, at least
      # let the user know which were the original warnings
      if ! setWarns "${warns}"; then logWarning $"restoring ignored warnings returned non-zero (:status) status! -- \`:warnings'" "status:$?" "warnings:${warns}"; errors='X'; fi

      # free lock file
      rm -f -- "${LOCKFILE}"
    fi
  fi
}

# ------------------------------------------------------------------------------
# -- Attach --------------------------------------------------------------------
# ------------------------------------------------------------------------------

# Perform the `attach' action
#
# Usage: doAttach
# Returns: 0, always
# Outputs: depends
# Depends:
doAttach() {
  #
  # $@: ATTACHSPECs to attach
  # force_attachment: 'Y' / 'N'
  #

  # try to read the lock file's line
  if ! readLock _ vmUID vmUUID prevRUNHASH auto_attach _ _ _ _; then
    logError $"no capturing virtual machine running!"; errors='X'
  else
    # check auto-attachment and forcing
    if [[ "${auto_attach}" == 'N' && "${force_attachment}" == 'N' ]]; then
      logError $"the capturing virtual machine is not accepting attachments! -- try forcing"; errors='X'
    else
      # check if the user may attach to the capturing virtual machine
      if (( ( UID != vmUID ) && UID )); then logError $"you're neither the capturing virtual machine's owner, nor root!"; errors='X'
      else
        # start building "attach" line, prepend "sudo" prefix
        if (( UID == 0 )); then line="sudo -Hnu '#${vmUID}' -- "; else line=''; fi

        # process each ATTACHSPEC in turn
        while (( $# )); do
          # determine if we're dealing with devpaths or folderspecs
          case "${1}" in
            # if the argument contains an `@' or `#' character, treat it as a FOLDERSPEC
            *@*|*\#*)
              # extract name and path
              nameSF="${1%%[@#]*}"; pathSF="${1#*[@#]}"
              # canonicalize path (mask errors)
              temp="$(readlink -e "${pathSF}")" ||:
              # check for path existence
              if [[ ! -d "${temp}" ]]; then logError $"invalid shared folder path! -- \`:path'" "path:${pathSF}"; errors='X'
              else
                pathSF="${temp}"

                # decide whether we're dealing with readonly folders or not
                if [[ "${1:${#nameSF}:1}" == '@' ]]; then
                  # evaluate attach line and report non-zero status
                  if ! eval -- "${line} vboxmanage sharedfolder add '${vmUUID}' --name '${nameSF}' --hostpath '${pathSF}' --transient 2> ${ERRPIPE}"; then
                    logWarning $"attaching shared folder \`:name' at path \`:path' returned non-zero (:status) status!" "name:${nameSF}" "path:${pathSF}" "status:$?"; errors='X'
                  fi
                else
                  # evaluate (readonly) attach line and report non-zero status
                  if ! eval -- "${line} vboxmanage sharedfolder add '${vmUUID}' --name '${nameSF}' --hostpath '${pathSF}' --transient --readonly 2> ${ERRPIPE}"; then
                    logWarning $"attaching read-only shared folder \`:name' at path \`:path' returned non-zero (:status) status!" "name:${nameSF}" "path:${pathSF}" "status:$?"; errors='X'
                  fi
                fi
              fi
            ;;
            # otherwise, it is a DEVPATH
            *)
              # get an address from the DEVPATH (mask errors)
              address="$(devpath2address "${1}")" ||:
              # show error if not a valid DEVPATH
              if ! [[ "${address}" ]]; then logError $"invalid devpath! -- \`:devpath'" "devpath:${1}"; errors='X'
              else
                # evaluate attach line and report non-zero status
                if ! eval -- "${line} vboxmanage controlvm '${vmUUID}' usbattach '${address}' 2> ${ERRPIPE}"; then
                  logWarning $"attaching devpath \`:devpath' at address \`:address' returned non-zero (:status) status!" "devpath:${1}" "address:${address}" "status:$?"; errors='X'
                fi
              fi
            ;;
          esac
          # shift the processed parameter out
          shift 1
        done
      fi
    fi
  fi
}

# ------------------------------------------------------------------------------
# -- Info ----------------------------------------------------------------------
# ------------------------------------------------------------------------------

# Perform the `info' action
#
# Usage: doInfo
# Returns: 0, always
# Outputs: depends
# Depends:
doInfo() {
  #
  # info_machine_readable: 'Y' / 'N'
  #

  # try to read the lock file's line
  if ! readLock vmPID vmUID vmUUID prevRUNHASH auto_attach attach_keyboard acpi_forward launch_print_listener use_new_X; then
    if [[ "${info_machine_readable}" == 'Y' ]]; then echo ''; else echo $"No vbht-managed virtual machine running!"; fi
  else
    if [[ "${info_machine_readable}" == 'Y' ]]; then
      echo "${vmPID}:${vmUID}:${vmUUID}:${prevRUNHASH}:${auto_attach}:${attach_keyboard}:${acpi_forward}:${launch_print_listener}:${use_new_X}"
    else
      # write formatted output to stdout
      println $"Capturing virtual machine's launcher PID: [:vmPID]"   "vmPID:${vmPID}"
      println $"Capturing virtual machine's launcher UID: [:vmUID]"   "vmUID:${vmUID}"
      println $"Capturing virtual machine's UUID        : [:vmUUID]"  "vmUUID:${vmUUID}"
      println $"Capturing virtual machine's RUNHASH     : [:runhash]" "runhash:${prevRUNHASH}"
      echo
      println $"Auto-attachment    : [:autoAttach]"          "autoAttach:${auto_attach}"
      println $"Keyboard attachment: [:attachKeyboard]"      "attachKeyboard:${attach_keyboard}"
      println $"ACPI forwarding    : [:acpiForward]"         "acpiForward:${acpi_forward}"
      println $"Print-listener     : [:launchPrintListener]" "launchPrintListener:${launch_print_listener}"
      println $"Dedicated X server : [:useNewX]"             "useNewX:${use_new_X}"
    fi
  fi
}

# ------------------------------------------------------------------------------
# -- Logs ----------------------------------------------------------------------
# ------------------------------------------------------------------------------

# Perform the `logs' action
#
# Usage: doLogs
# Returns: 0, always
# Outputs: depends
# Depends:
doLogs() {
  #
  # $@: machine descriptors (either of HASH / NAME / UUID / -)
  #
  # show_fatal  : 'Y' / 'N'
  # show_error  : 'Y' / 'N'
  # show_warning: 'Y' / 'N'
  # show_info   : 'Y' / 'N'
  # show_debug  : 'Y' / 'N'
  # show_stderr : 'Y' / 'N'
  #

  # set up severity pattern values
  temp=''
  if [[ "${show_fatal}"   == 'Y' ]]; then temp="${temp}F"; fi
  if [[ "${show_error}"   == 'Y' ]]; then temp="${temp}E"; fi
  if [[ "${show_warning}" == 'Y' ]]; then temp="${temp}W"; fi
  if [[ "${show_info}"    == 'Y' ]]; then temp="${temp}I"; fi
  if [[ "${show_debug}"   == 'Y' ]]; then temp="${temp}D"; fi
  if [[ "${show_stderr}"  == 'Y' ]]; then temp="${temp}S"; fi

  # process each descriptor in turn
  # general idea:
  # - each argument is first checked, and translated to a RUNHASH
  #   (NAME / UUID / - descriptors are "dereferenced") and pushed
  #   into an array for later processing
  # - once there are no more arguments left, process the array in
  #   question one item at a time using the severity pattern
  while (( $# )); do
    # check for "currently running machine" descriptor
    if [[ "${1}" == '-' ]]; then
      # - go read the lock file
      # - if there's no machine running, yell and be done with it
      # - if there's a machine running, get the RUNHASH and push it
      :
    else
      # this can either be a a machine's UUID, NAME, or HASH
      # - ask getUUID() to look for a machine thus identified
      # - if getUUID() failed, assume its a RUNHASH and push it,
      # - otherwise, scan the logs to get all the RUNHASHes matching
      #   the resulting UUID, push them all to the array
      :
    fi

    # shift the processed parameter out
    shift 1
  done

  # the actual magic comes here: the array will be holding RUNHASHes
  # into the logs; take each in turn and, using the severity pattern
  # show each to the user.
}

# ------------------------------------------------------------------------------
# -- Stop ----------------------------------------------------------------------
# ------------------------------------------------------------------------------

# Perform the `stop' action
#
# Usage: doStop
# Returns: 0, always
# Outputs: depends
# Depends:
doStop() {
  #
  # stop_method: 'A' / 'O' / 'R' / 'V' / 'S'
  # force_stop: 'Y' / 'N'
  #

  # be obnoxious about `--force' being ignored
  if [[ "${force_stop}" == 'Y' && ( "${stop_method}" != 'A' || "${stop_method}" != 'L' ) ]]; then
    logWarning $"forcing option will be ignored for stoppage type \`:stoppageType'" "stoppageType:${stop_method}"
  fi

  # try to read the lock file's line
  if ! readLock _ vmUID vmUUID prevRUNHASH _ _ acpi_forward _ _; then logError $"no capturing virtual machine running!"; errors='X'
  else
    # check if the user may stop the capturing virtual machine
    if (( ( UID != vmUID ) && UID )); then logError $"you're neither the capturing virtual machine's owner, nor root!"; errors='X'
    else
      # check ACPI forwarding and forcing
      if [[ ( "${stop_method}" != 'A' || "${stop_method}" != 'L' ) && "${acpi_forward}" == 'N' && "${force_stop}" == 'N' ]]; then
        logError $"the capturing virtual machine is not being forwarded ACPI events! -- try forcing"; errors='X'
      else
        # start building "stop" line
        line="vboxmanage controlvm '${vmUUID}'"
        # append stoppage type
        case "${stop_method}" in
          'A') line="${line} acpipowerbutton" ;;
          'O') line="${line} poweroff"        ;;
          'R') line="${line} reset"           ;;
          'S') line="${line} savestate"       ;;
          'L') line="${line} acpisleepbutton" ;;
          #
          *) logError $"invalid stoppage type! -- \`:stoppage'" "stoppage:${stop_method}"; errors='X' ;;
        esac
        # prepend "sudo" prefix
        if (( UID == 0 )); then line="sudo -Hnu '#${vmUID}' -- ${line}"; fi

        # evaluate stop line and report non-zero status
        if ! eval -- "${line} 2> ${ERRPIPE}"; then logWarning $"stoppage returned non-zero (:status) status!" "status:$?"; fi
      fi
    fi
  fi
}


# ==============================================================================
# == Constants =================================================================
# ==============================================================================

# ------------------------------------------------------------------------------
# -- System-related constants --------------------------------------------------
# ------------------------------------------------------------------------------

# stdout/stderr type
#  'C'  colour-capable tty (at least 8 colors available)
#  'M'  monochrome tty (or less than 8 colours)
#  'O'  other type of stderr (eg. pipe)
declare -u STDOUTTYPE='' STDERRTYPE=''
# determine stdout/stderr type
if [[ -t 1 ]]; then if (( $(tput colors 2> /dev/null) >= 8 )); then STDOUTTYPE='C'; else STDOUTTYPE='M'; fi; else STDOUTTYPE='O'; fi
if [[ -t 2 ]]; then if (( $(tput colors 2> /dev/null) >= 8 )); then STDERRTYPE='C'; else STDERRTYPE='M'; fi; else STDERRTYPE='O'; fi
# prevent accidental modification
readonly STDERRTYPE STDOUTTYPE

# ------------------------------------------------------------------------------
# -- Log-related constants -----------------------------------------------------
# ------------------------------------------------------------------------------

# hash's length (in characters / bytes)
declare -i HASHLENGTH=64
# hash for this script's run
declare -r RUNHASH=$(tr -cd '[:alnum:]' < /dev/urandom | head -c "${HASHLENGTH}")
# the previous RUNHASH
declare prevRUNHASH=''
# error pipe for this script's run (defined in terms of RUNHASH)
declare -r ERRPIPE="/tmp/ERRPIPE-${RUNHASH}"
# logfile directory
declare -r LOGDIR='/var/log/vbht'
# logfile name
declare -r LOGFILE="${LOGDIR}/vbht"

# maximum user settable verbosity
declare -ri MAX_VERB=6
# severities/verbosities
declare -ri SEV_STDERR=6 SEV_DEBUG=5 SEV_INFO=4 SEV_WARNING=3 SEV_ERROR=2 SEV_FATAL=1
# "other" is used to signify no pre-format is to be applied
declare -ri SEV_OTHER_VERB=0  # show to stderr
declare -ri SEV_OTHER_SLNT=7  # hide from stderr

# colours and shapes
declare START_STDERR=''  STOP_STDERR=''
declare START_DEBUG=''   STOP_DEBUG=''
declare START_INFO=''    STOP_INFO=''
declare START_WARNING='' STOP_WARNING=''
declare START_ERROR=''   STOP_ERROR=''
declare START_FATAL=''   STOP_FATAL=''
declare START_EMPH=''    STOP_EMPH=''
# initialise according to STDERRTYPE
if [[ "${STDERRTYPE}" == 'C' ]]; then
  START_STDERR="$( tput bold 2> /dev/null)$(tput setaf 4 2> /dev/null)" ||: ; STOP_STDERR="$( tput sgr0 2> /dev/null)" ||:
  START_DEBUG="$(  tput bold 2> /dev/null)$(tput setaf 6 2> /dev/null)" ||: ; STOP_DEBUG="$(  tput sgr0 2> /dev/null)" ||:
  START_INFO="$(   tput bold 2> /dev/null)$(tput setaf 2 2> /dev/null)" ||: ; STOP_INFO="$(   tput sgr0 2> /dev/null)" ||:
  START_WARNING="$(tput bold 2> /dev/null)$(tput setaf 3 2> /dev/null)" ||: ; STOP_WARNING="$(tput sgr0 2> /dev/null)" ||:
  START_ERROR="$(  tput bold 2> /dev/null)$(tput setaf 1 2> /dev/null)" ||: ; STOP_ERROR="$(  tput sgr0 2> /dev/null)" ||:
  START_FATAL="$(  tput bold 2> /dev/null)$(tput setaf 5 2> /dev/null)" ||: ; STOP_FATAL="$(  tput sgr0 2> /dev/null)" ||:
fi

if [[ "${STDOUTTYPE}" == 'C' || "${STDOUTTYPE}" == 'M' ]]; then
  START_EMPH="$(tput bold 2> /dev/null)" ||: ; STOP_EMPH="$(tput sgr0 2> /dev/null)" ||:
fi

# ------------------------------------------------------------------------------
# -- Lock-related constants ----------------------------------------------------
# ------------------------------------------------------------------------------

# lockfile name
declare -r LOCKFILE='/tmp/vbht'
# maximum lockfile read retries
declare -ri LOCKRETRIES=7

# ------------------------------------------------------------------------------
# -- Synchronization constants -------------------------------------------------
# ------------------------------------------------------------------------------

# initial dwell time used to attach keyboards, maximum number of tries for
# attaching keyboards, dwell time between keyboard attachment tries
declare -ri KBDATTACHINIDWELL=5 KBDATTACHMAXTRIES=20 KBDATTACHINTDWELL=2

# ------------------------------------------------------------------------------
# -- Misc constants ------------------------------------------------------------
# ------------------------------------------------------------------------------

# the actual home directory (valid for root under udev too)
declare -r HOME=${HOME:-/root}
# print directory name
declare -r PRINTDIR="${HOME}/.vbht-print"
# print pipe for this script's run (defined in terms of RUNHASH)
declare -r PRNPIPE="/tmp/PRNPIPE-${RUNHASH}"

# ignored VirtualBox(R) warnings
declare -r IGNOREWARNINGS='confirmGoingFullscreen,confirmGoingSeamless,confirmInputCapture,confirmVMReset,remindAboutAutoCapture,remindAboutGoingFullscreen,remindAboutGoingSeamless,remindAboutInputCapture,remindAboutMouseIntegrationOff,remindAboutMouseIntegrationOn,remindAboutPausedVMInput,remindAboutWrongColorDepth,showRuntimeError.warning.HostAudioNotResponding'


# ==============================================================================
# == Option variables ==========================================================
# ==============================================================================

# when this variable is non empty we've chanced upon errors
#  'S'  errors occurred, but be silent about it
#  'X'  errors occurred which need reporting
declare -u errors=''

# action to be taken
#  'S'  start
#  'A'  attach
#  'I'  info
#  'L'  logs
#  'X'  stop
declare -u action=''

# type of stoppage
#  'A'  ACPI off
#  'O'  power off  (default)
#  'R'  reset
#  'S'  save state
#  'L'  ACPI sleep
declare -u stop_method="${VBHT_STOP_METHOD:-O}"

# forced stoppage
#  'Y'  force ACPI forwarding
#  'N'  use machine's setting  (default)
declare -u force_stop="${VBHT_FORCE_STOP:-N}"

# whether to enable auto attachment
#  'Y'  enable auto-attachment  (default)
#  'N'  disable auto-attachment
#  'E'  auto-attachment has been disabled due to errors
declare -u auto_attach="${VBHT_AUTO_ATTACH:-Y}"

# forced attachment
#  'Y'  force ATTACHSPEC attachment
#  'N'  use machine's setting  (default)
declare -u force_attachment="${VBHT_FORCE_ATTACH:-N}"

# whether to enable (USB) keyboard attachment
#  'Y'  enable keyboard attachment  (default)
#  'N'  disable keyboard attachment
#  'E'  keyboard attachment has been disabled due to errors
declare -u attach_keyboard="${VBHT_ATTACH_KEYBOARD:-Y}"

# whether to forward ACPI (power/sleep button) events
#  'Y'  forward ACPI events  (default)
#  'N'  don't forward ACPI events
#  'E'  forwarding ACPI events has been disabled due to errors
declare -u acpi_forward="${VBHT_ACPI_FORWARD:-Y}"

# whether to launch the print listening service
#  'Y'  launch print listener  (default)
#  'N'  con't launch print listener
#  'E'  launching of print listener has been disabled due to errors
declare -u launch_print_listener="${VBHT_LAUNCH_PRINT_LISTENER:-Y}"

# whether to use a new instance of the X server
#  'Y'  use a new instance of the X server  (default)
#  'N'  don't use a new instance of the X server
#  'E'  using a new instance has been disabled due to errors
declare -u use_new_X="${VBHT_USE_NEW_X:-Y}"

# whether info should be shown in machine readable format
#  'Y'  show info in machine readable format (default if stderr is not a tty)
#  'N'  don't show info in machine readable format  (default otherwise)
declare -u info_machine_readable="${VBHT_INFO_MACHINE_READABLE:-}"
if [[ "${info_machine_readable}" == '' && "${STDOUTTYPE}" == 'O' ]]; then
  info_machine_readable='Y'
else
  info_machine_readable='N'
fi

# whether FATAL lines are to be shown
#  'Y'  show FATAL lines
#  'N'  hide FATAL lines
declare -u show_fatal='Y'
# whether ERROR lines are to be shown
#  'Y'  show ERROR lines
#  'N'  hide ERROR lines
declare -u show_error='Y'
# whether WARNING lines are to be shown
#  'Y'  show WARNING lines
#  'N'  hide WARNING lines
declare -u show_warning='Y'
# whether INFO lines are to be shown
#  'Y'  show INFO lines
#  'N'  hide INFO lines
declare -u show_info='Y'
# whether DEBUG lines are to be shown
#  'Y'  show DEBUG lines
#  'N'  hide DEBUG lines
declare -u show_debug='Y'
# whether STDERR lines are to be shown
#  'Y'  show STDERR lines
#  'N'  hide STDERR lines
declare -u show_stderr='Y'

# minimum severity to report to stderr (ignore errors in case VBHT_VERBOSITY
# can't parse as integer)
declare -i verbosity; (( verbosity = ${VBHT_VERBOSITY:-2} )) 2> /dev/null ||:

# ------------------------------------------------------------------------------
# -- Help display variables ----------------------------------------------------
# ------------------------------------------------------------------------------

# whether a parameter for a given action has already been seen
declare -i parameter_seen; (( parameter_seen = 1 ))


# ==============================================================================
# == General variables =========================================================
# ==============================================================================

# the UID of the (to be) capturing VM
declare -i vmUID=0
# the UUID of the (to be) capturing VM
declare -l vmUUID=''

# the PID of the process holding the lock
declare -i lockingPID=0
# current VirtualBox(R)'s PID
declare -i vbPID=0
# the PID of the (to be) capturing VM
declare -i vmPID=0

# the address of the (to be) attached USB device
declare address=''
# the name to be assigned to the (to be) created shared folder
declare nameSF=''
# the path to be assigned to the (to be) created shared folder
declare pathSF=''

# previous VirtualBox(R) warnings
declare warns=''
# disabled input devices list
declare indevs=''

# used to construct evaluatable lines
declare line=''
# used to hold return values in general
declare -i ret=0

# generic temporary
declare temp=''
# generic iterator
declare -i i=0


# ==============================================================================
# == Initialization ============================================================
# ==============================================================================

# declare PID variables
declare -i PNPID
declare -i PLPID
declare -i ELPID

# create the ERRPIPE FIFO
# @TODO: set up permissions on mkfifo with the "-m" parameter
mkfifo "${ERRPIPE}"
# create the ERRPIPE FIFO
# @TODO: set up permissions on mkfifo with the "-m" parameter
mkfifo "${PRNPIPE}"

# launch the listeners (do as in http://stackoverflow.com/a/715041 in order
# to suppress termination messages)
errListener   & ELPID=$!
printListener & PLPID=$!

disown "${ELPID}" "${PLPID}"


# ==============================================================================
# == Traps and logging =========================================================
# ==============================================================================

# trap the DEBUG signal and turn it into a log entry
trap "exitTrap" EXIT ERR
# trap the DEBUG signal and turn it into a log entry
trap "debugTrap \"\${BASH_COMMAND}\" \"\${FUNCNAME:-main}\" \"\${LINENO}\"" DEBUG

# logging starts here
declare -ru DO_TRAP_LOGGING='Y'


# ==============================================================================
# == Arguments check ===========================================================
# ==============================================================================

logDebug $"VBHT started"

# we must have at least one argument
if (( $# == 0 )); then logError $"no arguments provided!"; errors='X'
else
  # check for `--help' argument
  if [[ "${1}" == '-h' || "${1}" == '--help' ]]; then
    showHelp
    # just be obnoxious about `--help' not being the only argument given :P
    if (( $# != 1 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
    exit 0
  fi

  # check for `--version' argument
  if [[ "${1}" == '-V' || "${1}" == '--version' ]]; then
    showVersion
    # just be obnoxious about `--version' not being the only argument given :P
    if (( $# != 1 )); then logWarning $"\`--version' is supposed to be the ONLY argument given!"; fi
    exit 0
  fi

  # check for `--license' argument
  if [[ "${1}" == '-L' || "${1}" == '--license' ]]; then
    /usr/bin/env pager /opt/vbht/agplv3
    # just be obnoxious about `--license' not being the only argument given :P
    if (( $# != 1 )); then logWarning $"\`--license' is supposed to be the ONLY argument given!"; fi
    exit 0
  fi

  # process action parameter
  case "${1}" in
    'start')
      action='S'
      # check for too few arguments
      if (( $# == 1 )); then logError $"too few arguments!"; errors='X'
      else
        # save the argument
        vmUUID="${2}"
        # get optional arguments
        shift 2
        while (( $# )); do
          case "${1}" in
            # check for each long option
            '--auto-attach'   ) auto_attach='Y'           ;; '--no-auto-attach'   ) auto_attach='N'           ;;
            '--kbd-attach'    ) attach_keyboard='Y'       ;; '--no-kbd-attach'    ) attach_keyboard='N'       ;;
            '--acpi-forward'  ) acpi_forward='Y'          ;; '--no-acpi-forward'  ) acpi_forward='N'          ;;
            '--print-listener') launch_print_listener='Y' ;; '--no-print-listener') launch_print_listener='N' ;;
            '--new-X'         ) use_new_X='Y'             ;; '--no-new-X'         ) use_new_X='N'             ;;
            # check for verbosity options
            '--quiet') (( verbosity-- )) ||: ;; '--verbose') (( verbosity++ )) ||: ;;
            # check for help option
            '--help')
              showStartHelp
              # just be obnoxious about `--help' not being the only argument given :P
              if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
              exit 0
            ;;
            # check for end-of-options
            '--') shift 1; break ;;
            # check for short options
            -*)
              # process each in turn
              for (( i = 1; i < ${#1}; i++ )); do
                case "${1:$i:1}" in
                  'A') auto_attach='Y'           ;; 'a') auto_attach='N'           ;;
                  'K') attach_keyboard='Y'       ;; 'k') attach_keyboard='N'       ;;
                  'F') acpi_forward='Y'          ;; 'f') acpi_forward='N'          ;;
                  'P') launch_print_listener='Y' ;; 'p') launch_print_listener='N' ;;
                  'X') use_new_X='Y'             ;; 'x') use_new_X='N'             ;;
                  # check for verbosity options
                  'q') (( verbosity-- )) ||: ;; 'v') (( verbosity++ )) ||: ;;
                  # check for help option
                  'h')
                    showStartHelp
                    # just be obnoxious about `h' not being the only argument given :P
                    if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`-h' is supposed to be the ONLY argument given!"; fi
                    exit 0
                  ;;
                  # invalid option
                  *) logError $"invalid option at \`:longOption'! -- \`:shortOption'" "longOption:${1}" "shortOption:${1:$i:1}"; errors='X' ;;
                esac
                # we've seen a parameter this far
                (( parameter_seen = 1 ))
              done
            ;;
            # invalid option, can only be an attachspec
            *) break ;;
          esac
          # we've seen a parameter this far
          (( parameter_seen = 1 ))
          # shift the processed parameter out
          shift 1
        done
      fi
    ;;
    'attach')
      action='A'
      # check for too few arguments
      if (( $# == 1 )); then logError $"too few arguments!"; errors='X'
      else
        # get optional arguments
        shift 1
        while (( $# )); do
          case "${1}" in
            # check for forced
            '--force') force_attachment='Y' ;;
            # check for verbosity options
            '--quiet') (( verbosity-- )) ||: ;; '--verbose') (( verbosity++ )) ||: ;;
            # check for help option
            '--help')
              showAttachHelp
              # just be obnoxious about `--help' not being the only argument given :P
              if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
              exit 0
            ;;
            # check for end-of-options
            '--') shift 1; break ;;
            # check for short options
            -*)
              # process each in turn
              for (( i = 1; i < ${#1}; i++ )); do
                case "${1:$i:1}" in
                  # check for forced
                  'f') force_attachment='Y' ;;
                  # check for verbosity options
                  'q') (( verbosity-- )) ||: ;; 'v') (( verbosity++ )) ||: ;;
                  # check for help option
                  'h')
                    showAttachHelp
                    # just be obnoxious about `h' not being the only argument given :P
                    if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`-h' is supposed to be the ONLY argument given!"; fi
                    exit 0
                  ;;
                  # invalid option
                  *) logError $"invalid option at \`:longOption'! -- \`:shortOption'" "longOption:${1}" "shortOption:${1:$i:1}"; errors='X' ;;
                esac
                # we've seen a parameter this far
                (( parameter_seen = 1 ))
              done
            ;;
            # invalid option, can only be an attachspec
            *) break ;;
          esac
          # we've seen a parameter this far
          (( parameter_seen = 1 ))
          # shift the processed parameter out
          shift 1
        done
      fi
    ;;
    'info')
      action='I'
      # get optional arguments
      shift 1
      while (( $# )); do
        case "${1}" in
          # check for long options
          '--machine-readable') info_machine_readable='Y' ;; '--no-machine-readable') info_machine_readable='N' ;;
          # check for verbosity options
          '--quiet') (( verbosity-- )) ||: ;; '--verbose') (( verbosity++ )) ||: ;;
          # check for help option
          '--help')
            showInfoHelp
            # just be obnoxious about `--help' not being the only argument given :P
            if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
            exit 0
          ;;
          # check for short options
          -*)
            # process each in turn
            for (( i = 1; i < ${#1}; i++ )); do
              case "${1:$i:1}" in
                'M') info_machine_readable='Y' ;; 'm') info_machine_readable='N' ;;
                # check for verbosity options
                'q') (( verbosity-- )) ||: ;; 'v') (( verbosity++ )) ||: ;;
                # check for help option
                'h')
                  showInfoHelp
                  # just be obnoxious about `h' not being the only argument given :P
                  if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`-h' is supposed to be the ONLY argument given!"; fi
                  exit 0
                ;;
                # invalid option
                *) logError $"invalid option at \`:longOption'! -- \`:shortOption'" "longOption:${1}" "shortOption:${1:$i:1}"; errors='X' ;;
              esac
              # we've seen a parameter this far
              (( parameter_seen = 1 ))
            done
          ;;
          # invalid option
          *) logError $"invalid option! -- \`:option'" "option:${1}"; errors='X' ;;
        esac
        # we've seen a parameter this far
        (( parameter_seen = 1 ))
        # shift the processed parameter out
        shift 1
      done
    ;;
    'logs')
      action='L'
      # get optional arguments
      shift 1
      while (( $# )); do
        case "${1}" in
          # check for each long option
          '--show-fatal'  ) show_fatal='Y'   ;; '--no-show-fatal'  ) show_fatal='N'   ;;
          '--show-error'  ) show_error='Y'   ;; '--no-show-error'  ) show_error='N'   ;;
          '--show-warning') show_warning='Y' ;; '--no-show-warning') show_warning='N' ;;
          '--show-info'   ) show_info='Y'    ;; '--no-show-info'   ) show_info='N'    ;;
          '--show-debug'  ) show_debug='Y'   ;; '--no-show-debug'  ) show_debug='N'   ;;
          '--show-stderr' ) show_stderr='Y'  ;; '--no-show-stderr' ) show_stderr='N'  ;;
          # check for verbosity options
          '--quiet') (( verbosity-- )) ||: ;; '--verbose') (( verbosity++ )) ||: ;;
          # check for help option
          '--help')
            showLogsHelp
            # just be obnoxious about `--help' not being the only argument given :P
            if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
            exit 0
          ;;
          # check for end-of-options
          '--') shift 1; break ;;
          # check for "currently running machine" descriptor
          '-') break ;;
          # check for short options
          -*)
            # process each in turn
            for (( i = 1; i < ${#1}; i++ )); do
              case "${1:$i:1}" in
                'F') show_fatal='Y'   ;; 'f') show_fatal='N'   ;;
                'E') show_error='Y'   ;; 'e') show_error='N'   ;;
                'W') show_warning='Y' ;; 'w') show_warning='N' ;;
                'I') show_info='Y'    ;; 'i') show_info='N'    ;;
                'D') show_debug='Y'   ;; 'd') show_debug='N'   ;;
                'S') show_stderr='Y'  ;; 's') show_stderr='N'  ;;
                # check for verbosity options
                'q') (( verbosity-- )) ||: ;; 'v') (( verbosity++ )) ||: ;;
                # check for help option
                'h')
                  showLogsHelp
                  # just be obnoxious about `h' not being the only argument given :P
                  if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`-h' is supposed to be the ONLY argument given!"; fi
                  exit 0
                ;;
                # invalid option
                *) logError $"invalid option at \`:longOption'! -- \`:shortOption'" "longOption:${1}" "shortOption:${1:$i:1}"; errors='X' ;;
              esac
              # we've seen a parameter this far
              (( parameter_seen = 1 ))
            done
          ;;
          # invalid option, can only be a descriptor
          *) break ;;
        esac
        # we've seen a parameter this far
        (( parameter_seen = 1 ))
        # shift the processed parameter out
        shift 1
      done
    ;;
    'stop')
      action='X'
      # get optional arguments
      shift 1
      while (( $# )); do
        case "${1}" in
          # check for each option
          '--acpi' ) stop_method='A' ;;
          '--off'  ) stop_method='O' ;;
          '--reset') stop_method='R' ;;
          '--save' ) stop_method='S' ;;
          '--sleep') stop_method='L' ;;
          # check for forced
          '--force') force_stop='Y' ;;
          # check for verbosity options
          '--quiet') (( verbosity-- )) ||: ;; '--verbose') (( verbosity++ )) ||: ;;
          # check for help option
          '--help')
            showStopHelp
            # just be obnoxious about `--help' not being the only argument given :P
            if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`--help' is supposed to be the ONLY argument given!"; fi
            exit 0
          ;;
          # check for short options
          -*)
            # process each in turn
            for (( i = 1; i < ${#1}; i++ )); do
              case "${1:$i:1}" in
                'a') stop_method='A' ;;
                'o') stop_method='O' ;;
                'r') stop_method='R' ;;
                's') stop_method='S' ;;
                'l') stop_method='L' ;;
                # check for forced
                'f') force_stop='Y' ;;
                # check for verbosity options
                'q') (( verbosity-- )) ||: ;; 'v') (( verbosity++ )) ||: ;;
                # check for help option
                'h')
                  showStopHelp
                  # just be obnoxious about `h' not being the only argument given :P
                  if (( $# != 1 || parameter_seen != 0 )); then logWarning $"\`-h' is supposed to be the ONLY argument given!"; fi
                  exit 0
                ;;
                # invalid option
                *) logError $"invalid option at \`:longOption'! -- \`:shortOption'" "longOption:${1}" "shortOption:${1:$i:1}"; errors='X' ;;
              esac
              # we've seen a parameter this far
              (( parameter_seen = 1 ))
            done
          ;;
          # invalid option
          *) logError $"invalid option! -- \`:option'" "option:${1}"; errors='X' ;;
        esac
        # we've seen a parameter this far
        (( parameter_seen = 1 ))
        # shift the processed parameter out
        shift 1
      done
    ;;
    *) logError $"invalid action! -- \`:action'" "action:${1}"; errors='X' ;;
  esac
fi

# in case of errors, show info and exit
if [[ "${errors}" ]]; then
  case "${action}" in
    'S') println $"Try \`:vbhtName start --help' for more information." "vbhtName:${0##*/}"  >&2 ;;
    'A') println $"Try \`:vbhtName attach --help' for more information." "vbhtName:${0##*/}" >&2 ;;
    'I') println $"Try \`:vbhtName info --help' for more information." "vbhtName:${0##*/}"   >&2 ;;
    'L') println $"Try \`:vbhtName logs --help' for more information." "vbhtName:${0##*/}"   >&2 ;;
    'X') println $"Try \`:vbhtName stop --help' for more information." "vbhtName:${0##*/}"   >&2 ;;
    #
    *) println $"Try \`:vbhtName --help' for more information." "vbhtName:${0##*/}" >&2 ;;
  esac
  exit 1
fi

# fix up verbosity
if (( verbosity > MAX_VERB )); then (( verbosity = ${MAX_VERB} )); fi
if (( verbosity < 0        )); then (( verbosity = 0           )); fi

# prevent accidental modification
readonly action verbosity


# ==============================================================================
# == Actual work ===============================================================
# ==============================================================================

# dispatch action
case "${action}" in
  'S') doStart  ;;
  'A') doAttach ;;
  'I') doInfo   ;;
  'L') doLogs   ;;
  'X') doStop   ;;
  #
  *) logError $"something went very wrong! late-unrecognised action: \`:action'!" "action:${action}"; errors='X' ;;
esac

# ==============================================================================
# == Finalisation ==============================================================
# ==============================================================================

# yell about errors
if [[ "${errors}" == 'X' ]]; then echo $"Errors were encountered, check logs!!!" >&2; fi
# return 1 in case of errors
if [[ "${errors}" ]]; then exit 1; fi


# 'twas a good day :)
exit 0
